CST /parse tree:

parse ();

generate_public_ast ();

???
=============================
Profit!
=============================
AST:

resolve ()
1. if it's not (a candidate for) attribute, resolve own data type 
1.1 if exists, it's MarkupTemp 
1.2 if not exists, it's a ComplexAttribute (w/ text as children, or MarkupRoot node). Add to parent.

2. recurse step 1. over children

resolve_hints ():
3. cherry-pick creation and composition methods => parameter resolution
  Given a data type, set aside creation parameters. These will be used with base() or base.parameter etc.
(DONE for creation methods of temps. TODO for all tags, and for composition methods)
TODO:
- break creation method into - detection (so that base () can complain no explicit method allowed) 
                         and - matching
- write construct and creation method assignments
4. recurse step 3. over children

resolve_attributes ():
5. attribute resolution. Recurse over children
TODO: unroll the resolving loop so that it's recursive and can be re-used from ComplexAttribute (with the resolver's help)
(hint: ComplexAttribute should not derive from MarkupTag. Instead, it should *have* a MarkupRoot)


=====TODO======!!!
WTF's the difference between Symbol and DataType?
 Short answer: A symbol has one or more data types
Define the exact order of determining attributes, complex attributes etc. given that some (g:preconstruct for example) are built-in!!
