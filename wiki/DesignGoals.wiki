#summary goals done + future goals
#labels Featured

See [DesignGoals#Future_Goals Future Goals] - "not done".

=Achieved Goals=
==goals for 0.1 (DONE)==
  * the gtkaml XML tags correspond to existing GObject classes(DONE in 0.1), and their attributes correspond to GObject properties, signals or fields(DONE in 0.1)

  * the XML namespace URI includes the Vala namespace name(DONE in 0.1) followed by a colon (':') and the Vala pkg name (optional). The namespace you're creating can be specified in `gtkaml:namespace` attribute (DONE in 0.1):

{{{
<Gtkns.Window xmlns:Gtkns="Gtk:gtk+-2.0" xmlns:GLibns="GLib" xmlns:gtkaml="http://gtkaml.org/0.1" gtkaml:namespace="myNamespace" gtkaml:name="MyWindow">
...
</Gtkns.Window>
}}}
  * the gtkaml namespace name may be changed as long as its URI begins with `http://gtkaml.org/` (DONE in 0.1)

  * the root tag represents the class that you're extending(DONE in 0.1), and the `gtkaml:name` represents the name of the class you're creating(DONE in 0.1):

{{{
using Gtk;
using GLib;
namespace myNamespace {
   public class MyWindow : Gtk.Window { ... } 
}
}}}
  * the other tags are declared as locals in the `construct` method (DONE in 0.1) and code is generated so that their properties are set(DONE in 0.1) and they are added to the parent container(DONE in 0.1)

{{{
<Window xmlns="Gtk:gtk+-2.0" xmlns:GLibns="GLib" title="gtkaml window">
    <Label label="test" />
</Window>
}}}
generates:
{{{
   private Gtk.Label label1;
   construct {
       this.title = "gtkaml window";
       label1 = new Gtk.Label();
       label1.label = "test";
       this.add(label1);
   }
}}}
  * the `gtkaml:public` and `gtkaml:private` attributes can set a name and visibility of a tag and declare it as a class member(DONE in 0.1):

{{{
<Window xmlns="Gtk:gtk+-2.0" xmlns:GLibns="GLib" title="gtkaml window">
    <Label gtkaml:public="myLabel" label="test" />
</Window>
}}}
generates:
{{{
   public Gtk.Label myLabel;
   construct {
       this.title = "gtkaml window";
       myLabel = new Gtk.Label();
       myLabel.label = "test";
       this.add(myLabel);
   }
}}}
  * attributes can be specified as sub-tags too (e.g. for multiline values or complex literals like array ones) (DONE in 0.1)

{{{
    <Label gtkaml:public="myLabel" >
         <label>multiline 
label</label>
    </Label>
}}}

  * code can be written in CDATA sections of the root tag(DONE in 0.1)

{{{
<Window xmlns="Gtk:gtk+-2.0" xmlns:GLibns="GLib">
   <![CDATA[
   private function on_click() { 
      stdout.printf("clicked!\n"); 
   } ]]>
</Window>
}}}
  * signals are properties holding code as their value (e.g. a function call). The parameters are `target`(the emmiter) and the other parameters from the signal signature, with the same names(DONE in 0.1)

{{{
<Window xmlns="Gtk:gtk+-2.0" xmlns:GLibns="GLib">
   <Label gtkaml:public="myLabel" label="test" clicked="on_click()"/>   
   <![CDATA[
   private function on_click() { 
      stdout.printf("clicked!\n"); 
   } ]]>
</Window>
}}}
  * attributes that are not literals can be specified with {} surrounding an identifier or expression (DONE in 0.1)

{{{
   <string gtkaml:public="myString">There is no spoon</string>
   <Label gtkaml:public="myLabel" label="{myString}"/>
}}}   
  * signals can be written in between {} too - this way you have to specify yourself the lambda function (DONE in 0.1):

{{{
<Window xmlns="Gtk:gtk+-2.0" xmlns:GLibns="GLib">
   <Label gtkaml:public="myLabel" label="test" clicked="{target=>{on_click()}}"/>   
   ...
}}}

  * creation methods are automatically determined based on the attributes present. If you want to use a specific creation method, specify his name as an attribute with the value "true" (DONE in 0.1):

{{{
   <Label with_mnemonic="true" label="_Shortcut"/>
}}}
  * the functions used to add child widgets to containers are automatically detected. If you want to use a specific container add function, specify his name as an attribute with the value "true" (DONE in 0.1):

{{{
   <VBox homogeneous="true" spacing="0">
       <Label pack_end="true" label="packed at end" />
   </VBox>
}}}

==Goals for 0.2 (DONE)==

  * the `gtkaml:construct` and `gtkaml:preconstruct` are used to specify a method/code to be called before/after the construction of the ui, given that you cannot have another `construct` method (DONE in 0.2). The version with {} specifies a method (or lambda function), while the version without {} specifies verbatim executable code. Also, a default parameter `target` is be available (DONE in 0.2)

  * the `gtkaml:implements` root attribute is used to specify a comma-separated interface list (DONE in 0.2)

  * a class member can be 'added' multiple times in a container (thus skipping the creation) by specifying ~~`gtkaml:reference="identifier"`~~ ~~(DONE in 0.1.1.1)~~  `gtkaml:existing="identifier"` (DONE in 0.2). ~~Of course, no other attribute than the parameters to the add function shall be specified on a reference.~~ The values without {} will be cast to the tag class (DONE in 0.2)
{{{
   <TreeViewColumn title="col1">
       <CellRendererText gtkaml:private="renderer1" pack_start="true" expand="true" />
       <CellRendererText gtkaml:existing="renderer1" add_attribute="true" attribute="text" column="0" />
   </TreeViewColumn>
}}}

  * `gtkaml:standalone="true"` as attribute allows the beginning of a UI description that doesn't get added to a parent container. This way, using `<VBox gtkaml:standalone="true" gtkaml:existing="dialog.vbox" ...` enables you to customize an existing area of a dialog. (DONE in 0.2)

  * the creation method of the base class must be respected: all required creation methods' parameters must be specified for the root tag (DONE in 0.2). Otherwise the implicits definition file must have default values (see below).  

  * The creation methods / container add methods can have default values for parameters in implicits configuration files. These are not taken into account when establishing maximum method match (DONE in 0.2)

  * the implicits.ini file is renamed to Gtk.implicits; when using a namespace, the implicits resolver looks up the namespacename.implicits in gtkaml's data folder and in --implicitsdir (DONE in 0.2)

  * xmlns:gtkaml URI versions are taken into account: give a warning if the source level is not specified or not <=0.2 (http://gtkaml.org/ is not specified, http://gtkaml.org/0.1 is 0.1 level). Also give warnings when the source level is > than the gtkaml version. (DONE in 0.2)

  * attributes can be hyphen-separated instead of underscores (e.g. `destroy-event`  instead of `destroy_event`) (DONE in 0.2)

=Future Goals=

==Goals for 0.2.x.x==

  * delete generated files unless --save-temps present (DONE in 0.2.0.1)
  * align generated .vala source lines to the first code island lines (DONE in 0.2.0.1)
  * allow signals to be container add functions (e.g. Container.add () is a signal and it is not used right now) (TODO)
  * fix existing bugs + reformulate .implicits parsing code (TODO)
  * cleanup source (using latest vala features such as 'construct set') (TODO)
  * ~~introduce `gtkaml:type` as alternative to `gtkaml:name` and issue a warning about the latter (see Goals for 0.3) (TODO)~~
  * (optional) explicit dot notation for add() parameters and for attributes-as-subtags? (is it TODO?)

==Goals for 0.3==
To think about:
  * internationalization
  * data binding? 
By using the 'notify' event of GLib.Object we can re-evaluate a property value on each change of one of its tokens. 

For example, `label="mystring + yourstring"` would create a lambda expression that's evaluated in three places: at Label's initialization, at 'mystring' change notification and at 'yourstring' change notification. 

The difficulty lies in determining the identifiers from the expression and then determining their owner object. 

Alternative notation: `label=" (mystring, yourstring) => {mystring + yourstring}"`. This would mean that we deprecate literals?
  * ~~rename gtkaml:name to gtkaml:type and allow it on other tags than root (which have gtkaml:private or gtkaml:public) just so that you can declare an interface and instantiate a class? should we break the syntax for this?~~
  * introduce `gtkaml:show-all="true"` which basically sets `visible="true"` on all child widgets unless explicitly set invisible.
  * GtkBuildable by default?

==Goals for 1.0 syntax stable==
  * vala re-entrant parser (allows to generate AST directly instead of code, and to parse 'code islands')